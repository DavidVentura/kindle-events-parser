use enum_primitive::*;
/* automatically generated by rust-bindgen 0.56.0 */
const __GNUC_VA_LIST: u32 = 1;
const LAB126_LOG_INFO: u32 = 8388608;
const LAB126_LOG_WARNING: u32 = 16777216;
const LAB126_LOG_ERROR: u32 = 33554432;
const LAB126_LOG_CRITICAL: u32 = 67108864;
const LAB126_LOG_DEBUG_ALL: u32 = 65280;
const LAB126_LOG_ALL: u32 = 4294967040;
type va_list = __builtin_va_list;
type __gnuc_va_list = __builtin_va_list;
type size_t = ::std::os::raw::c_ulong;
type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " LIPC library handler."]
#[allow(clippy::upper_case_acronyms)]
type LIPC = ::std::os::raw::c_void;
const LIPCcode_LIPC_OK: LIPCcode = 0;
const LIPCcode_LIPC_ERROR_UNKNOWN: LIPCcode = 1;
const LIPCcode_LIPC_ERROR_INTERNAL: LIPCcode = 2;
const LIPCcode_LIPC_ERROR_NO_SUCH_SOURCE: LIPCcode = 3;
const LIPCcode_LIPC_ERROR_OPERATION_NOT_SUPPORTED: LIPCcode = 4;
const LIPCcode_LIPC_ERROR_OUT_OF_MEMORY: LIPCcode = 5;
const LIPCcode_LIPC_ERROR_SUBSCRIPTION_FAILED: LIPCcode = 6;
const LIPCcode_LIPC_ERROR_NO_SUCH_PARAM: LIPCcode = 7;
const LIPCcode_LIPC_ERROR_NO_SUCH_PROPERTY: LIPCcode = 8;
const LIPCcode_LIPC_ERROR_ACCESS_NOT_ALLOWED: LIPCcode = 9;
const LIPCcode_LIPC_ERROR_BUFFER_TOO_SMALL: LIPCcode = 10;
const LIPCcode_LIPC_ERROR_INVALID_HANDLE: LIPCcode = 11;
const LIPCcode_LIPC_ERROR_INVALID_ARG: LIPCcode = 12;
const LIPCcode_LIPC_ERROR_OPERATION_NOT_ALLOWED: LIPCcode = 13;
const LIPCcode_LIPC_ERROR_PARAMS_SIZE_EXCEEDED: LIPCcode = 14;
const LIPCcode_LIPC_ERROR_TIMED_OUT: LIPCcode = 15;
const LIPCcode_LIPC_ERROR_SERVICE_NAME_TOO_LONG: LIPCcode = 16;
const LIPCcode_LIPC_ERROR_DUPLICATE_SERVICE_NAME: LIPCcode = 17;
const LIPCcode_LIPC_ERROR_INIT_DBUS: LIPCcode = 18;
const LIPCcode_LIPC_PROP_ERROR_INVALID_STATE: LIPCcode = 256;
const LIPCcode_LIPC_PROP_ERROR_NOT_INITIALIZED: LIPCcode = 257;
const LIPCcode_LIPC_PROP_ERROR_INTERNAL: LIPCcode = 258;

enum_from_primitive! {
#[derive(Debug, PartialEq)]
#[repr(u32)] // FIXME: No idea how to make a c_int here
enum ReturnCodes {
    OK = LIPCcode_LIPC_OK,
    ERROR_UNKNOWN = 1,
    ERROR_INTERNAL = 2,
    ERROR_NO_SUCH_SOURCE = 3,
    ERROR_OPERATION_NOT_SUPPORTED = 4,
    ERROR_OUT_OF_MEMORY = 5,
    ERROR_SUBSCRIPTION_FAILED = 6,
    ERROR_NO_SUCH_PARAM = 7,
    ERROR_NO_SUCH_PROPERTY = 8,
    ERROR_ACCESS_NOT_ALLOWED = 9,
    ERROR_BUFFER_TOO_SMALL = 10,
    ERROR_INVALID_HANDLE = 11,
    ERROR_INVALID_ARG = 12,
    ERROR_OPERATION_NOT_ALLOWED = 13,
    ERROR_PARAMS_SIZE_EXCEEDED = 14,
    ERROR_TIMED_OUT = 15,
    ERROR_SERVICE_NAME_TOO_LONG = 16,
    ERROR_DUPLICATE_SERVICE_NAME = 17,
    ERROR_INIT_DBUS = 18,
    PROP_ERROR_INVALID_STATE = 256,
    PROP_ERROR_NOT_INITIALIZED = 257,
    PROP_ERROR_INTERNAL = 258,
}
}
#[doc = " Status codes returned by all sorts of LIPC library functions."]
#[doc = ""]
#[doc = " @warning"]
#[doc = " This list was obtained from the LipcGetErrorString() function and may"]
#[doc = " be not complete - be prepared for other values as well."]
type LIPCcode = ::std::os::raw::c_uint;
#[doc = " LIPC hash-array handler."]
type LIPCha = ::std::os::raw::c_void;
const LIPCHasharrayType_LIPC_HASHARRAY_INT: LIPCHasharrayType = 0;
const LIPCHasharrayType_LIPC_HASHARRAY_STRING: LIPCHasharrayType = 1;
const LIPCHasharrayType_LIPC_HASHARRAY_BLOB: LIPCHasharrayType = 2;
#[doc = " Possible data types, which can be stored in the value of the hash component"]
#[doc = " in the hash-array data structure."]
type LIPCHasharrayType = ::std::os::raw::c_uint;

#[link(name = "lipc")]
extern "C" {
    #[doc = " Initialize LIPC library without registering a new service."]
    #[doc = ""]
    #[doc = " @return On success the LIPC library handler is returned, which should be"]
    #[doc = "   closed with the LipcClose(). Upon error this function returns NULL."]
    fn LipcOpenNoName() -> *mut LIPC;
    #[doc = " Initialize LIPC library and register a new service."]
    #[doc = ""]
    #[doc = " @param service The service name which should be registered. The name has"]
    #[doc = "   to be a fully qualified dot-separated identifier, e.g. \"org.MyService\"."]
    #[doc = " @return On success the LIPC library handler is returned, which should be"]
    #[doc = "   closed with the LipcClose(). Upon error this function returns NULL."]
    fn LipcOpen(service: *const ::std::os::raw::c_char) -> *mut LIPC;
    #[doc = " Initialize LIPC library and register a new service."]
    #[doc = ""]
    #[doc = " This function is an extended version of the LipcOpen()."]
    #[doc = ""]
    #[doc = " @param service The service name which should be registered. The name has"]
    #[doc = "   to be a fully qualified dot-separated identifier, e.g. \"org.MyService\"."]
    #[doc = " @param code If not NULL, the status code will be stored in this argument."]
    #[doc = " @return On success the LIPC library handler is returned, which should be"]
    #[doc = "   closed with the LipcClose(). Upon error this function returns NULL."]
    fn LipcOpenEx(service: *const ::std::os::raw::c_char, code: *mut LIPCcode) -> *mut LIPC;
    #[doc = " Close the LIPC handler and release all associated resources."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    fn LipcClose(lipc: *mut LIPC);
    #[doc = " Get the service name associated with the LIPC handler."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @return The service name which was registered during LIPC opening or NULL"]
    #[doc = "   if the handler was obtained by the call to the LipcOpenNoName()."]
    fn LipcGetServiceName(lipc: *mut LIPC) -> *const ::std::os::raw::c_char;
    #[doc = " Get status code in the string format."]
    #[doc = ""]
    #[doc = " @param code The status code."]
    #[doc = " @return String with the human-readable status."]
    fn LipcGetErrorString(code: LIPCcode) -> *const ::std::os::raw::c_char;
    #[doc = " Initialize new hash-array data structure."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @return The LIPC hash-array handler or NULL upon error."]
    fn LipcHasharrayNew(lipc: *mut LIPC) -> *mut LIPCha;
    #[doc = " Free resources associated with the hash-array handler."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @param destroy If TRUE, the underlying shared memory segment will be marked"]
    #[doc = "   to be destroyed."]
    #[doc = " @return The status code."]
    fn LipcHasharrayFree(ha: *mut LIPCha, destroy: ::std::os::raw::c_int) -> LIPCcode;
    #[doc = " Free resources associated with the hash-array handler."]
    #[doc = ""]
    #[doc = " This function is an equivalent of calling the LipcHasharrayFree() function"]
    #[doc = " with the destroy parameter set to TRUE."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @return The status code."]
    fn LipcHasharrayDestroy(ha: *mut LIPCha) -> LIPCcode;
    #[doc = " Get the number of elements in the array component of the hash-array data"]
    #[doc = " structure."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @return The array size or -1 upon error."]
    fn LipcHasharrayGetHashCount(ha: *mut LIPCha) -> ::std::os::raw::c_int;
    #[doc = " Append new hash map to the hash-array structure."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @param index The address where the index of newly added hash map (hence,"]
    #[doc = "   the size of the array) will be stored."]
    #[doc = " @return The status code."]
    fn LipcHasharrayAddHash(ha: *mut LIPCha, index: *mut size_t) -> LIPCcode;
    #[doc = " Get keys stored in the hash map of the hash-array data structure."]
    #[doc = ""]
    #[doc = " In order to determine the number of keys at the given index, one should"]
    #[doc = " call this function with the count parameter initialized to 0. The number"]
    #[doc = " of available keys will be returned back in this parameter - in fact the"]
    #[doc = " count parameter is always modified, and the number of keys is returned in"]
    #[doc = " it (be careful when reusing this variable for iteration over keys array)."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @param index The 0-based index in the array."]
    #[doc = " @param keys The array which can store up to the count number of string"]
    #[doc = "   pointers - keys."]
    #[doc = " @param count The address where the number of keys to fetch is given."]
    #[doc = " @return The status code."]
    fn LipcHasharrayKeys(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        keys: *mut *const ::std::os::raw::c_char,
        count: *mut size_t,
    ) -> LIPCcode;
    #[doc = " Get the data type stored in the hash map of the hash-array data structure."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @param index The 0-based index in the array."]
    #[doc = " @param key The key name to check."]
    #[doc = " @param type The address where the data type will be stored."]
    #[doc = " @param size The address where the size of the value will be stored."]
    #[doc = " @return The status code."]
    fn LipcHasharrayCheckKey(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        type_: *mut LIPCHasharrayType,
        size: *mut size_t,
    ) -> LIPCcode;
    #[doc = " Get the integer value form the hash map of the hash-array data structure."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @param index The 0-based index in the array."]
    #[doc = " @param key The key name to get."]
    #[doc = " @param value The address where the integer value will be stored."]
    #[doc = " @return The status code."]
    fn LipcHasharrayGetInt(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> LIPCcode;
    #[doc = " Put the integer value into the hash map of the hash-array data structure."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @param index The 0-based index in the array."]
    #[doc = " @param key The key name to set."]
    #[doc = " @param value The value to set."]
    #[doc = " @return The status code."]
    fn LipcHasharrayPutInt(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> LIPCcode;
    #[doc = " Get the string value form the hash map of the hash-array data structure."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @param index The 0-based index in the array."]
    #[doc = " @param key The key name to get."]
    #[doc = " @param value The address where the pointer to the string will be stored."]
    #[doc = " @return The status code."]
    fn LipcHasharrayGetString(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> LIPCcode;
    #[doc = " Put the string value into the hash map of the hash-array data structure."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @param index The 0-based index in the array."]
    #[doc = " @param key The key name to set."]
    #[doc = " @param value The value to set."]
    #[doc = " @return The status code."]
    fn LipcHasharrayPutString(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> LIPCcode;
    #[doc = " Get the blob data from the hash map of the hash-array data structure."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @param index The 0-based index in the array."]
    #[doc = " @param key The key name to get."]
    #[doc = " @param data The address where the pointer to the data will be stored."]
    #[doc = " @param size The address where the size of the data will be stored."]
    #[doc = " @return The status code."]
    fn LipcHasharrayGetBlob(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        size: *mut size_t,
    ) -> LIPCcode;
    #[doc = " Put the blob data into the hash map of the hash-array data structure."]
    #[doc = ""]
    #[doc = " @param ha The LIPC hash-array handler."]
    #[doc = " @param index The 0-based index in the array."]
    #[doc = " @param key The key name to set."]
    #[doc = " @param data The data to set."]
    #[doc = " @param size The size of the data."]
    #[doc = " @return The status code."]
    fn LipcHasharrayPutBlob(
        ha: *mut LIPCha,
        index: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_uchar,
        size: size_t,
    ) -> LIPCcode;
    #[doc = " Copy a hash-array data structure."]
    #[doc = ""]
    #[doc = " The destination hash-array structure handler has to be initialized with the"]
    #[doc = " LipcHasharrayNew() function."]
    #[doc = ""]
    #[doc = " @param dest The destination hash-array handler."]
    #[doc = " @param src The source hash-array handler."]
    #[doc = " @return The status code."]
    fn LipcHasharrayCopy(dest: *mut LIPCha, src: *const LIPCha) -> LIPCcode;
    #[doc = " Copy a single hash map of the hash-array data structure."]
    #[doc = ""]
    #[doc = " The destination hash-array structure handler has to be initialized with the"]
    #[doc = " LipcHasharrayNew() function."]
    #[doc = ""]
    #[doc = " @param dest The destination hash-array handler."]
    #[doc = " @param dest_index The index in the destination hash-array structure, where"]
    #[doc = "   the copied hash map will be placed."]
    #[doc = " @param src The source hash-array handler."]
    #[doc = " @param src_index The index within the source hash-array structure, from"]
    #[doc = "   where the hash map is copied."]
    #[doc = " @return The status code."]
    fn LipcHasharrayCopyHash(
        dest: *mut LIPCha,
        dest_index: ::std::os::raw::c_int,
        src: *const LIPCha,
        src_index: ::std::os::raw::c_int,
    ) -> LIPCcode;
    #[doc = " Clone a hash-array data structure."]
    #[doc = ""]
    #[doc = " This function is (almost) an equivalent of calling the LipcHasharrayCopy()"]
    #[doc = " function using a newly initialized hash-array handler. However, using this"]
    #[doc = " function ensures, that the internal hash-array key and few other internal"]
    #[doc = " fields are copied too. The exact meaning of these fields is unknown."]
    #[doc = ""]
    #[doc = " @param ha The hash-array handler to the structure which should be cloned."]
    #[doc = " @return On success the LIPC hash-array handler to the new data structure"]
    #[doc = "   is returned. Upon error this function returns NULL."]
    fn LipcHasharrayClone(ha: *const LIPCha) -> *mut LIPCha;
    #[doc = " Save hash-array memory into the given file descriptor."]
    #[doc = ""]
    #[doc = " @param ha The hash-array handler."]
    #[doc = " @param fd Opened file descriptor with the write permission."]
    #[doc = " @return The status code."]
    fn LipcHasharraySave(ha: *const LIPCha, fd: ::std::os::raw::c_int) -> LIPCcode;
    #[doc = " Restore hash-array form the memory read from the given file descriptor."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param fd Opened file descriptor with the read permission."]
    #[doc = " @return On success the LIPC hash-array handler to the restored data"]
    #[doc = "   structure is returned. Upon error this function returns NULL."]
    fn LipcHasharrayRestore(lipc: *mut LIPC, fd: ::std::os::raw::c_int) -> *mut LIPCha;
    #[doc = " Get string representation of the given hash-array."]
    #[doc = ""]
    #[doc = " In order to determine the number of bytes required to store the string"]
    #[doc = " representation of the given hash-array data structure, one should call this"]
    #[doc = " function with the size parameter initialized to 0. The number of required"]
    #[doc = " bytes will be returned back in this parameter - in fact the size parameter"]
    #[doc = " is always modified, and the number of required bytes is returned in it (be"]
    #[doc = " careful when reusing this variable)."]
    #[doc = ""]
    #[doc = " @param ha The hash-array handler."]
    #[doc = " @param str The pointer to the address, where the hash-array string"]
    #[doc = "   representation will be stored."]
    #[doc = " @param size The pointer to the address, where the size of the str buffer"]
    #[doc = "   is passed. On return, the number of actually used bytes will be stored"]
    #[doc = "   at this address."]
    #[doc = " @return The status code."]
    fn LipcHasharrayToString(
        ha: *const LIPCha,
        str_: *mut ::std::os::raw::c_char,
        size: *mut size_t,
    ) -> LIPCcode;
    #[doc = " Get property access timeout."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " The timeout value can be set via the file \"/var/local/system/lipctimeout\","]
    #[doc = " otherwise it is set to the default 10000 ms."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @return The timeout value in milliseconds."]
    fn LipcGetPropAccessTimeout(lipc: *mut LIPC) -> ::std::os::raw::c_int;
    #[doc = " Get the value of the integer property."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param service The service name."]
    #[doc = " @param property The property name."]
    #[doc = " @param value The address where the integer value will be stored."]
    #[doc = " @return The status code."]
    #[must_use]
    fn LipcGetIntProperty(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> LIPCcode;
    #[doc = " Set the value of the integer property."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param service The service name."]
    #[doc = " @param property The property name."]
    #[doc = " @param value The new value to set."]
    #[doc = " @return The status code."]
    fn LipcSetIntProperty(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> LIPCcode;
    #[doc = " Get the value of the string property."]
    #[doc = ""]
    #[doc = " The memory for the returned string is allocated internally by the library"]
    #[doc = " and should be freed with the LipcFreeString()."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param service The service name."]
    #[doc = " @param property The property name."]
    #[doc = " @param value The address where the pointer to the string will be stored."]
    #[doc = " @return The status code."]
    fn LipcGetStringProperty(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> LIPCcode;
    #[doc = " Set the value of the string property."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param service The service name."]
    #[doc = " @param property The property name."]
    #[doc = " @param value The new value to set."]
    #[doc = " @return The status code."]
    fn LipcSetStringProperty(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> LIPCcode;
    #[doc = " Access the value of the hash-array property."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param service The service name."]
    #[doc = " @param property The property name."]
    #[doc = " @param ha An input LIPC hash-array handler or NULL if there is no input."]
    #[doc = " @param ha_out The pointer to the address, where the output hash-array"]
    #[doc = "   handler will be stored. If the output value is not desired, one can"]
    #[doc = "   pass NULL value in this parameter."]
    #[doc = " @return The status code."]
    fn LipcAccessHasharrayProperty(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        ha: *const LIPCha,
        ha_out: *mut *mut LIPCha,
    ) -> LIPCcode;
    #[doc = " Free memory allocated by the LIPC."]
    #[doc = ""]
    #[doc = " @param string The string pointer."]
    fn LipcFreeString(string: *mut ::std::os::raw::c_char);
}
#[doc = " Property getter/setter callback function."]
#[doc = ""]
#[doc = " This callback function can be used either for getting properties or for"]
#[doc = " setting ones. However, there is a slight difference in both actions. Also,"]
#[doc = " there is a difference when the callback function is called for getting a"]
#[doc = " string, and when it is called for getting an integer."]
#[doc = ""]
#[doc = " When the getter is called for the integer property, one has to set the"]
#[doc = " address pointed by the *value to the desired integer value."]
#[doc = ""]
#[doc = " When the getter is called for the string property, the buffer pointed by"]
#[doc = " the *value is preallocated to the initial size. This size is available in"]
#[doc = " the *data parameter. If the buffer is too small for storing desired string"]
#[doc = " value, one should return the LIPC_ERROR_BUFFER_TOO_SMALL code and pass the"]
#[doc = " required buffer size in the *data argument. In such a case, the callback"]
#[doc = " function will be called again with the requested buffer size."]
#[doc = ""]
#[doc = " When the setter is called, the value parameter contains the integer value"]
#[doc = " itself or it points to the memory buffer, respectively for the integer"]
#[doc = " property or for the string property."]
#[doc = ""]
#[doc = " For convenience, one can use one of the helper macros (LIPC_GETTER_VTOI(),"]
#[doc = " LIPC_SETTER_VTOI(), LIPC_GETTER_VTOS() or LIPC_SETTER_VTOS()) for casting"]
#[doc = " the value parameter into the proper type based on the callback type."]
#[doc = ""]
#[doc = " In all cases, with the exception of the string property getter, the data"]
#[doc = " parameter will contain the value passed during the property registration."]
#[doc = ""]
#[doc = " The return value of the callback function will be used as a return value"]
#[doc = " for the caller, e.g. LipcGetIntProperty(). One exception from this rule is"]
#[doc = " a getter for a string property, where the LIPC_ERROR_BUFFER_TOO_SMALL code"]
#[doc = " is used internally by the LIPC library."]
#[doc = ""]
#[doc = " @param lipc LIPC library handler."]
#[doc = " @param property The property name."]
#[doc = " @param value Pointer to the memory area for a value storage."]
#[doc = " @param data Data passed during property registration."]
#[doc = " @return The status code."]
type LipcPropCallback = ::std::option::Option<
    unsafe extern "C" fn(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode,
>;
#[doc = " Event dispatching callback function."]
#[doc = ""]
#[doc = " @param lipc LIPC library handler."]
#[doc = " @param name The event name."]
#[doc = " @param event The LIPC event handler."]
#[doc = " @param data Data pointer passed during subscription."]
#[doc = " @return The status code."]
type LipcEventCallback = ::std::option::Option<
    unsafe extern "C" fn(
        lipc: *mut LIPC,
        name: *const ::std::os::raw::c_char,
        event: *mut LIPCevent,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode,
>;
#[doc = " LIPC event handler."]
type LIPCevent = ::std::os::raw::c_void;

extern "C" {
    #[doc = " Register new integer property."]
    #[doc = ""]
    #[doc = " The access mode of the property is determined by the presence of the getter"]
    #[doc = " and/or the setter callback function. Passing NULL value in the getter and"]
    #[doc = " the setter parameters will make the property read-only, however it will not"]
    #[doc = " be possible to retrieve any value, so it is pointless to do so."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param property The property name."]
    #[doc = " @param getter Getter callback if property is readable."]
    #[doc = " @param setter Setter callback if property is writable."]
    #[doc = " @param data Data pointer passed to the callback function."]
    #[doc = " @return The status code."]
    fn LipcRegisterIntProperty(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        getter: LipcPropCallback,
        setter: LipcPropCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
    #[doc = " Register new string property."]
    #[doc = ""]
    #[doc = " For the information about the property access mode, see the documentation"]
    #[doc = " of the LipcRegisterIntProperty()."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param property The property name."]
    #[doc = " @param getter Getter callback if property is readable."]
    #[doc = " @param setter Setter callback if property is writable."]
    #[doc = " @param data Data pointer passed to the callback function."]
    #[doc = " @return The status code."]
    fn LipcRegisterStringProperty(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        getter: LipcPropCallback,
        setter: LipcPropCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
    #[doc = " Register new hash-array property."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param property The property name."]
    #[doc = " @param callback Getter and setter callback function."]
    #[doc = " @param data Data pointer passed to the callback function."]
    #[doc = " @return The status code."]
    fn LipcRegisterHasharrayProperty(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        callback: LipcPropCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
    #[doc = " Unregister property."]
    #[doc = ""]
    #[doc = " If the data parameter is not NULL, the address of the data pointer passed"]
    #[doc = " during the property registration will be stored in the address pointed by"]
    #[doc = " the *data."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param property The property name."]
    #[doc = " @param data Address where the data pointer is returned."]
    #[doc = " @return The status code."]
    fn LipcUnregisterProperty(
        lipc: *mut LIPC,
        property: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
    #[doc = " Create a new event object."]
    #[doc = ""]
    #[doc = " In order to use this function the LIPC handler has to be opened with the"]
    #[doc = " service name given using LipcOpen() or LipcOpenEx()."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param name The event name."]
    #[doc = " @return On success the LIPCevent handler is returned, which should be freed"]
    #[doc = "   with the LipcEventFree(). Upon error this function returns NULL."]
    fn LipcNewEvent(lipc: *mut LIPC, name: *const ::std::os::raw::c_char) -> *mut LIPCevent;
    #[doc = " Free memory allocated by the LIPC."]
    #[doc = ""]
    #[doc = " @param event LIPC event handler."]
    fn LipcEventFree(event: *mut LIPCevent);
    #[doc = " Send event object."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param event LIPC event handler."]
    #[doc = " @return The status code."]
    fn LipcSendEvent(lipc: *mut LIPC, event: *mut LIPCevent) -> LIPCcode;
    #[doc = " Create and send event."]
    #[doc = ""]
    #[doc = " This function is an equivalent of using LipcNewEvent(), LipcSendEvent() and"]
    #[doc = " LipcEventFree() all together. If you want to send a simple event object -"]
    #[doc = " one without any parameters - use this function."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param name The event name."]
    #[doc = " @return The status code."]
    fn LipcCreateAndSendEvent(lipc: *mut LIPC, name: *const ::std::os::raw::c_char) -> LIPCcode;
    #[doc = " Create and send event."]
    #[doc = ""]
    #[doc = " This function creates an event object and sets its parameters according to"]
    #[doc = " the format string. This function takes variable number of arguments."]
    #[doc = ""]
    #[doc = " LIPC supports two kinds of event parameters: integers and strings. It is"]
    #[doc = " possible to specify both of these types via the format string in the same"]
    #[doc = " way the printf() function family does. The format string can contain any"]
    #[doc = " number of \"%d\" or/and \"%s\" conversion specifiers. It is also possible to"]
    #[doc = " pass an empty string in the format argument, which will be an equivalent"]
    #[doc = " of calling the LipcCreateAndSendEvent()."]
    #[doc = ""]
    #[doc = " The format string also supports the \".0\" precision modifier. However, its"]
    #[doc = " purpose is yet to be discovered."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param name The event name."]
    #[doc = " @param format The format string."]
    #[doc = " @param ... Variable list of parameters."]
    #[doc = " @return The status code."]
    fn LipcCreateAndSendEventWithParameters(
        lipc: *mut LIPC,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> LIPCcode;
    #[doc = " Create and send event."]
    #[doc = ""]
    #[doc = " This function creates an event object and sets its parameters according to"]
    #[doc = " the format string. Parameter values should be passed as a variable argument"]
    #[doc = " list. For the list of all supported formats, see the documentation of the"]
    #[doc = " LipcCreateAndSendEventWithParameters() function."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param name The event name."]
    #[doc = " @param format The format string."]
    #[doc = " @param ap Variable argument list."]
    #[doc = " @return The status code."]
    fn LipcCreateAndSendEventWithVAListParameters(
        lipc: *mut LIPC,
        name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> LIPCcode;
    #[doc = " Get the source name associated with the event."]
    #[doc = ""]
    #[doc = " @param event LIPC event handler."]
    #[doc = " @return The source name from where the event originates."]
    fn LipcGetEventSource(event: *mut LIPCevent) -> *const ::std::os::raw::c_char;
    #[doc = " Get the name of the event."]
    #[doc = ""]
    #[doc = " @param event LIPC event handler."]
    #[doc = " @return The event name."]
    fn LipcGetEventName(event: *mut LIPCevent) -> *const ::std::os::raw::c_char;
    #[doc = " Get the integer parameter from the event."]
    #[doc = ""]
    #[doc = " @param event LIPC event handler."]
    #[doc = " @param value The address where the integer value will be stored."]
    #[doc = " @return The status code."]
    fn LipcGetIntParam(event: *mut LIPCevent, value: *mut ::std::os::raw::c_int) -> LIPCcode;
    #[doc = " Add the integer parameter to the event."]
    #[doc = ""]
    #[doc = " @param event LIPC event handler."]
    #[doc = " @param value The new value to add."]
    #[doc = " @return The status code."]
    fn LipcAddIntParam(event: *mut LIPCevent, value: ::std::os::raw::c_int) -> LIPCcode;
    #[doc = " Get the string parameter from the event."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " The obtained memory pointer should not be passed to the LipcFreeString()"]
    #[doc = " function. It seems, that the memory is managed internally by the library."]
    #[doc = ""]
    #[doc = " @param event LIPC event handler."]
    #[doc = " @param value The address where the pointer to the string will be stored."]
    #[doc = " @return The status code."]
    fn LipcGetStringParam(
        event: *mut LIPCevent,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> LIPCcode;
    #[doc = " Add the string parameter to the event."]
    #[doc = ""]
    #[doc = " @param event LIPC event handler."]
    #[doc = " @param value The new value to add."]
    #[doc = " @return The status code."]
    fn LipcAddStringParam(event: *mut LIPCevent, value: *const ::std::os::raw::c_char) -> LIPCcode;
    #[doc = " Rewind parameters of the event."]
    #[doc = ""]
    #[doc = " @param event LIPC event handler."]
    #[doc = " @return The status code."]
    fn LipcRewindParams(event: *mut LIPCevent) -> LIPCcode;
    #[doc = " Set default event callback function."]
    #[doc = ""]
    #[doc = " The callback function will be called when one uses the LipcSubscribe()"]
    #[doc = " subscription mechanism. Note, that it is not possible to pass user-defined"]
    #[doc = " data via this approach - if one wants to pass extra data to the callback"]
    #[doc = " function, one should use the LipcSubscribeExt() instead."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param callback Event dispatching callback function."]
    #[doc = " @return The status code."]
    fn LipcSetEventCallback(lipc: *mut LIPC, callback: LipcEventCallback) -> LIPCcode;
    #[doc = " Subscribe for all events emitted by the service."]
    #[doc = ""]
    #[doc = " In order to receive event notifications, one has to set default callback"]
    #[doc = " function using the LipcSetEventCallback() function. Using them both, is an"]
    #[doc = " equivalent of using the extended version with parameters set as follows:"]
    #[doc = " LipcSubscribeExt(lipc, service, NULL, callback, NULL)"]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param service The service name."]
    #[doc = " @return The status code."]
    fn LipcSubscribe(lipc: *mut LIPC, service: *const ::std::os::raw::c_char) -> LIPCcode;
    #[doc = " Subscribe for events emitted by the service."]
    #[doc = ""]
    #[doc = " This function is an extended version of the LipcSubscribe(), which allows"]
    #[doc = " to set the event name for which one wants to subscribe and the user-defined"]
    #[doc = " data passed to the callback function. Passing NULL instead of the event"]
    #[doc = " name will subscribe for all events."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param service The service name."]
    #[doc = " @param name The event name."]
    #[doc = " @param callback Event dispatching callback function."]
    #[doc = " @param data Data pointer passed to the callback function."]
    #[doc = " @return The status code."]
    fn LipcSubscribeExt(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        callback: LipcEventCallback,
        data: *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
    #[doc = " Unsubscribe from event or events."]
    #[doc = ""]
    #[doc = " If the event name is NULL, this function will unsubscribe from events"]
    #[doc = " delivered to the callback set with the LipcSetEventCallback()."]
    #[doc = ""]
    #[doc = " @param lipc LIPC library handler."]
    #[doc = " @param service The service name."]
    #[doc = " @param name The event name or NULL."]
    #[doc = " @param data Address where the data pointer is returned or NULL."]
    #[doc = " @return The status code."]
    fn LipcUnsubscribeExt(
        lipc: *mut LIPC,
        service: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> LIPCcode;
    static mut g_lab126_log_mask: ::std::os::raw::c_int;
    #[doc = " Set the LIPC internal logging mask."]
    #[doc = ""]
    #[doc = " The logging mask parameter should be the logical OR of the logging flags"]
    #[doc = " (LAB126_LOG_* definitions). The current state of the logging mask can be"]
    #[doc = " accessed via the g_lab126_log_mask global variable."]
    #[doc = ""]
    #[doc = " @param mask The logging mask."]
    fn LipcSetLlog(mask: ::std::os::raw::c_int);
}
type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
