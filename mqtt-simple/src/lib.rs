#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_bigendian_conversion() {
        let expected = vec![0, 11];
        assert_eq!(Protocol::to_big_endian(11), expected);
    }
    #[test]
    fn test_connect_payload() {
        let expected = vec![
            16, 23, 0, 4, 77, 81, 84, 84, 4, 2, 0, 5, 0, 11, 99, 108, 105, 101, 110, 116, 95, 110,
            97, 109, 101,
        ];
        assert_eq!(Protocol::connect_payload("client_name", 5), expected);
    }

    #[test]
    fn test_publish_payload() {
        let expected = vec![
            48, 22, 0, 10, 115, 111, 109, 101, 95, 116, 111, 112, 105, 99, 109, 121, 32, 109, 101,
            115, 115, 97, 103, 101,
        ];
        assert_eq!(
            Protocol::publish_payload("some_topic", "my message", false, QoS::AtMostOnce, 0),
            expected
        );
    }

    #[test]
    fn test_long_publish_payload() {
        // 150 x 'a' -> test
        let expected = vec![
            0x30, 0x9c, 0x01, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x61, 0x61, 0x61,
        ];
        assert_eq!(
            Protocol::publish_payload("test",
                                      "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                                      false, QoS::AtMostOnce, 0),
            expected
        );
    }
    #[test]
    fn test_super_long_publish_payload() {
        let expected = vec![
            0x30, 0xfd, 0x05, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74, 0x7b, 0x22, 0x63, 0x6f, 0x6e,
            0x74, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x7b,
            0x22, 0x74, 0x65, 0x78, 0x74, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x2c, 0x22, 0x72,
            0x61, 0x6e, 0x67, 0x65, 0x22, 0x3a, 0x7b, 0x22, 0x62, 0x65, 0x67, 0x69, 0x6e, 0x22,
            0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x2c, 0x22, 0x65, 0x6e, 0x64, 0x22, 0x3a, 0x6e, 0x75,
            0x6c, 0x6c, 0x7d, 0x7d, 0x2c, 0x22, 0x70, 0x61, 0x67, 0x65, 0x42, 0x6f, 0x75, 0x6e,
            0x64, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x65, 0x78, 0x74, 0x22, 0x3a, 0x6e, 0x75,
            0x6c, 0x6c, 0x2c, 0x22, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x22, 0x3a, 0x7b, 0x22, 0x62,
            0x65, 0x67, 0x69, 0x6e, 0x22, 0x3a, 0x22, 0x31, 0x30, 0x39, 0x38, 0x38, 0x32, 0x38,
            0x22, 0x2c, 0x22, 0x65, 0x6e, 0x64, 0x22, 0x3a, 0x22, 0x31, 0x31, 0x30, 0x30, 0x37,
            0x34, 0x31, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74,
            0x49, 0x74, 0x65, 0x6d, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x22,
            0x3a, 0x22, 0x4a, 0x6f, 0x65, 0x20, 0x41, 0x62, 0x65, 0x72, 0x63, 0x72, 0x6f, 0x6d,
            0x62, 0x69, 0x65, 0x20, 0x2d, 0x20, 0x54, 0x68, 0x65, 0x20, 0x42, 0x6c, 0x61, 0x64,
            0x65, 0x20, 0x49, 0x74, 0x73, 0x65, 0x6c, 0x66, 0x22, 0x2c, 0x22, 0x63, 0x6f, 0x6e,
            0x74, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x22, 0x3a, 0x22, 0x5c, 0x2f, 0x6d, 0x6e, 0x74,
            0x5c, 0x2f, 0x75, 0x73, 0x5c, 0x2f, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
            0x73, 0x5c, 0x2f, 0x49, 0x74, 0x73, 0x65, 0x6c, 0x66, 0x2c, 0x20, 0x54, 0x68, 0x65,
            0x20, 0x42, 0x6c, 0x61, 0x64, 0x65, 0x5c, 0x2f, 0x4a, 0x6f, 0x65, 0x20, 0x41, 0x62,
            0x65, 0x72, 0x63, 0x72, 0x6f, 0x6d, 0x62, 0x69, 0x65, 0x20, 0x2d, 0x20, 0x54, 0x68,
            0x65, 0x20, 0x42, 0x6c, 0x61, 0x64, 0x65, 0x20, 0x49, 0x74, 0x73, 0x65, 0x6c, 0x66,
            0x20, 0x2d, 0x20, 0x54, 0x68, 0x65, 0x20, 0x42, 0x6c, 0x61, 0x64, 0x65, 0x20, 0x49,
            0x74, 0x73, 0x65, 0x6c, 0x66, 0x20, 0x28, 0x76, 0x31, 0x2e, 0x30, 0x29, 0x2e, 0x6d,
            0x6f, 0x62, 0x69, 0x22, 0x2c, 0x22, 0x61, 0x73, 0x69, 0x6e, 0x22, 0x3a, 0x22, 0x64,
            0x32, 0x64, 0x30, 0x35, 0x66, 0x30, 0x34, 0x2d, 0x38, 0x63, 0x62, 0x64, 0x2d, 0x34,
            0x64, 0x33, 0x37, 0x2d, 0x62, 0x37, 0x30, 0x30, 0x2d, 0x32, 0x64, 0x65, 0x39, 0x32,
            0x39, 0x34, 0x31, 0x38, 0x32, 0x38, 0x33, 0x22, 0x2c, 0x22, 0x63, 0x6f, 0x6e, 0x74,
            0x65, 0x6e, 0x74, 0x47, 0x75, 0x69, 0x64, 0x22, 0x3a, 0x22, 0x4a, 0x6f, 0x65, 0x5f,
            0x41, 0x62, 0x65, 0x72, 0x63, 0x72, 0x6f, 0x6d, 0x62, 0x69, 0x65, 0x5f, 0x2d, 0x5f,
            0x54, 0x68, 0x65, 0x5f, 0x42, 0x6c, 0x61, 0x64, 0x65, 0x5f, 0x49, 0x74, 0x73, 0x3a,
            0x38, 0x34, 0x45, 0x44, 0x35, 0x46, 0x34, 0x33, 0x22, 0x2c, 0x22, 0x62, 0x6f, 0x6f,
            0x6b, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x22, 0x3a, 0x31, 0x33, 0x32, 0x36, 0x39,
            0x39, 0x31, 0x2c, 0x22, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x22, 0x3a, 0x22, 0x54,
            0x68, 0x65, 0x20, 0x42, 0x6c, 0x61, 0x64, 0x65, 0x20, 0x49, 0x74, 0x73, 0x65, 0x6c,
            0x66, 0x20, 0x28, 0x76, 0x31, 0x2e, 0x30, 0x29, 0x22, 0x2c, 0x22, 0x70, 0x75, 0x62,
            0x6c, 0x69, 0x73, 0x68, 0x65, 0x72, 0x49, 0x64, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c,
            0x7d, 0x2c, 0x22, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x4d, 0x65, 0x74, 0x61,
            0x64, 0x61, 0x74, 0x61, 0x22, 0x3a, 0x7b, 0x22, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
            0x74, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x65, 0x22, 0x3a, 0x22, 0x65, 0x6e, 0x22, 0x2c,
            0x22, 0x68, 0x61, 0x73, 0x54, 0x4f, 0x43, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c,
            0x22, 0x65, 0x6e, 0x64, 0x4f, 0x66, 0x42, 0x6f, 0x6f, 0x6b, 0x50, 0x6f, 0x73, 0x69,
            0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x31, 0x33, 0x32, 0x36, 0x39, 0x39, 0x31,
            0x22, 0x2c, 0x22, 0x73, 0x74, 0x61, 0x72, 0x74, 0x52, 0x65, 0x61, 0x64, 0x69, 0x6e,
            0x67, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x31, 0x35,
            0x34, 0x36, 0x38, 0x22, 0x2c, 0x22, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x4c,
            0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x2c,
            0x22, 0x68, 0x61, 0x73, 0x43, 0x6f, 0x76, 0x65, 0x72, 0x22, 0x3a, 0x66, 0x61, 0x6c,
            0x73, 0x65, 0x2c, 0x22, 0x6c, 0x61, 0x73, 0x74, 0x57, 0x6f, 0x72, 0x64, 0x50, 0x6f,
            0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x31, 0x33, 0x32, 0x36, 0x39,
            0x32, 0x34, 0x22, 0x2c, 0x22, 0x73, 0x74, 0x61, 0x72, 0x74, 0x4f, 0x66, 0x42, 0x6f,
            0x6f, 0x6b, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x31,
            0x30, 0x39, 0x22, 0x2c, 0x22, 0x69, 0x73, 0x50, 0x61, 0x67, 0x65, 0x4e, 0x75, 0x6d,
            0x62, 0x65, 0x72, 0x69, 0x6e, 0x67, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65,
            0x64, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x63, 0x64, 0x65, 0x54, 0x79,
            0x70, 0x65, 0x22, 0x3a, 0x22, 0x45, 0x42, 0x4f, 0x4b, 0x22, 0x7d, 0x7d,
        ];
        let payload = Protocol::publish_payload(
            "test",
            r#"{"contentSection":{"text":null,"range":{"begin":null,"end":null}},"pageBounds":{"text":null,"range":{"begin":"1098828","end":"1100741"}},"contentItem":{"title":"Joe Abercrombie - The Blade Itself","contentId":"\/mnt\/us\/documents\/Itself, The Blade\/Joe Abercrombie - The Blade Itself - The Blade Itself (v1.0).mobi","asin":"d2d05f04-8cbd-4d37-b700-2de929418283","contentGuid":"Joe_Abercrombie_-_The_Blade_Its:84ED5F43","bookLength":1326991,"author":"The Blade Itself (v1.0)","publisherId":null},"contentMetadata":{"contentLocale":"en","hasTOC":true,"endOfBookPosition":"1326991","startReadingPosition":"15468","contentLanguage":null,"hasCover":false,"lastWordPosition":"1326924","startOfBookPosition":"109","isPageNumberingSupported":true,"cdeType":"EBOK"}}"#,
            false,
            QoS::AtMostOnce,
            0,
        );
        for (k, _) in payload.iter().enumerate() {
            if payload[k] != expected[k] {
                println!(
                    "At pos {}, payload {}, expected {}",
                    k, payload[k], expected[k]
                )
            }
        }
        assert_eq!(payload, expected);
    }
}

use std::io::prelude::*;
use std::io::{self, Read};
use std::net::{SocketAddr, TcpStream, ToSocketAddrs};

pub struct Client {
    name: String,
    server: String,
}
pub struct ConnectedClient {
    socket: TcpStream,
    pid: u16,
    keepalive: u8,
}
struct Protocol {}

#[repr(u8)]
#[derive(Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum QoS {
    AtMostOnce = 0,
    AtLeastOnce = 1,
    ExactlyOnce = 2,
}

pub fn publish_once(
    name: String,
    server: String,
    topic: &str,
    message: &str,
    retain: bool,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut c = Client::new(name, server)?;
    let mut cc = c.connect(5)?;
    cc.publish(topic, message, retain, QoS::AtMostOnce)?;
    Ok(())
}

impl Client {
    pub fn new(name: String, server: String) -> Result<Client, std::net::AddrParseError> {
        Ok(Client {
            name,
            server: format!("{}:1883", server),
        })
    }

    pub fn connect(
        &mut self,
        keepalive: u8,
    ) -> Result<ConnectedClient, Box<dyn std::error::Error>> {
        let payload = Protocol::connect_payload(self.name.as_ref(), keepalive);
        println!("Conencting to {}", self.server);
        let s: Vec<_> = self.server.to_socket_addrs()?.collect();
        let s = &s.into_iter().next().unwrap();
        println!("Conencting to {:?}", s);
        let mut stream = TcpStream::connect_timeout(s, std::time::Duration::from_secs(3))?;
        stream.write(payload.as_ref())?;

        let mut buf = vec![0 as u8; 4];
        stream.read_exact(&mut buf)?;
        assert!(buf[0] == 0x20);
        assert!(buf[1] == 0x02);
        assert!(buf[3] == 0x00);

        Ok(ConnectedClient {
            socket: stream,
            keepalive,
            pid: 0,
        })
    }
}
impl ConnectedClient {
    pub fn publish(
        &mut self,
        topic: &str,
        msg: &str,
        retain: bool,
        qos: QoS,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let payload = Protocol::publish_payload(topic, msg, retain, qos, self.pid);
        self.socket.write(payload.as_ref())?;
        self.pid += 1;

        self.drain_ping();
        Ok(())
    }

    fn drain_ping(&mut self) {
        let mut buf: Vec<u8> = Vec::new();
        self.socket.set_nonblocking(true).unwrap();
        match self.socket.read_to_end(&mut buf) {
            Ok(_) => (),
            Err(e) => {
                if e.kind() != io::ErrorKind::WouldBlock {
                    panic!(e)
                }
            }
        };
        self.socket.set_nonblocking(false).unwrap();
        if buf.len() > 0 {
            println!("Stuff on the queue!! {:?}", buf);
        }
    }
}

impl Drop for ConnectedClient {
    fn drop(&mut self) {
        let res = self.socket.write(vec![0xe0, 0x0].as_ref());
        if res.is_err() {
            println!("Error disconnecting! {:?}", res);
        }
    }
}
impl Protocol {
    fn connect_payload(client_id: &str, keepalive: u8) -> Vec<u8> {
        let mut premsg: Vec<u8> = Vec::new();
        premsg.push(0x10);

        let mut msg = vec![0x0, 0x4, b'M', b'Q', b'T', b'T', 4, 2, 0, 0];

        let mut size: u8 = 10 + 2 + client_id.len() as u8;
        let clean_session = 1;
        msg[7] = clean_session << 1;

        // keepalive is u8 so keepalive >> 8 is always 0
        // and keepalive & 0xFF is always keepalive
        msg[8] |= 0;
        msg[9] |= keepalive;

        while size > 0x7f {
            println!("Size stuff {}", size);
            premsg.push((size & 0x7f) | 0x0);
            size >>= 7;
        }
        premsg.push(size);

        let mut payload: Vec<u8> = vec![];
        payload.extend(premsg);
        payload.extend(msg);
        payload.extend(Protocol::to_big_endian(client_id.len() as u16));
        payload.extend(client_id.as_bytes());
        payload
    }

    fn publish_payload(topic: &str, msg: &str, retain: bool, qos: QoS, pid: u16) -> Vec<u8> {
        let mut pkt: Vec<u8> = Vec::new();
        pkt.push(0x30);

        let mut size: u32 = 2 + topic.len() as u32 + msg.len() as u32;
        if qos > QoS::AtMostOnce {
            size += 2
        }
        pkt[0] |= ((qos as u8) << 1) | (retain as u8);

        while size > 0x7f {
            pkt.push(((size & 0x7f) | 0x80) as u8);
            size >>= 7;
        }
        pkt.push(size as u8);
        pkt.extend(Protocol::to_big_endian(topic.len() as u16));
        pkt.extend(topic.as_bytes());

        if qos > QoS::AtMostOnce {
            pkt.extend(Protocol::to_big_endian(pid));
        }
        pkt.extend(msg.as_bytes());
        pkt
    }

    fn to_big_endian(n: u16) -> Vec<u8> {
        vec![(n >> 8) as u8, (n & 0xFF) as u8]
    }
}
